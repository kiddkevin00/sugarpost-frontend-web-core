{"version":3,"sources":["../../../../../../src/lib/client/src/common/dispatcher/AppDispatcher.js"],"names":["AppDispatcher"],"mappings":";;;;;;AAAA;;AAEA,IAAMA,gBAAgB,sBAAtB;;kBAEeA,a;;AAEf;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"AppDispatcher.js","sourcesContent":["import { Dispatcher } from 'flux';\n\nconst AppDispatcher = new Dispatcher();\n\nexport default AppDispatcher;\n\n/*\n * Source code for `require('flux').Dispatcher` is the following:\n */\n\n//var Promise = require('es6-promise').Promise;\n//\n//var _callbacks = [];\n//var _promises = [];\n//\n//var Dispatcher = function() {};\n//Dispatcher.prototype = Object.assign({}, Dispatcher.prototype, {\n//\n//  /**\n//   * Register a Store's callback so that it may be invoked by an action.\n//   *\n//   * @param  {Function} callback                                              - the callback to be registered\n//   * @return {number}   the index of the callback within the _callbacks array\n//   */\n//  register: function(callback) {\n//    _callbacks.push(callback);\n//    return _callbacks.length - 1; // index\n//  },\n//\n//  /**\n//   * Dispatch an action.\n//   *\n//   * @param {Object} payload - the data from the action\n//   */\n//  dispatch: function(payload) {\n//    // first create an array of promises for callbacks to reference.\n//    var resolves = [];\n//    var rejects = [];\n//    _promises = _callbacks.map(function(_, i) {\n//      return new Promise(function(resolve, reject) {\n//        resolves[i] = resolve;\n//        rejects[i] = reject;\n//      });\n//    });\n//    // dispatch to callbacks and resolve/reject promises.\n//    _callbacks.forEach(function(callback, i) {\n//      // `callback` can return an obj, to resolve, or a promise, to chain\n//      // check `waitFor()` for why this might be useful\n//      Promise.resolve(callback(payload)).then(function() {\n//        resolves[i](payload);\n//      }, function() {\n//        rejects[i](new Error('Dispatcher callback unsuccessful'));\n//      });\n//    });\n//    _promises = [];\n//  },\n//\n//  /**\n//   * @param  {Array}    promiseIndexes\n//   * @param  {Function} callback\n//   */\n//  waitFor: function(promiseIndexes, callback) {\n//    var selectedPromises = promiseIndexes.map(function(index) {\n//      return _promises[index];\n//    });\n//    return Promise.all(selectedPromises).then(callback);\n//  }\n//});\n"]}